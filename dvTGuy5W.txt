--========================
-- üî• SNIPEX ITS (UI + INSTAN STEAL + AUTO KICK + ESP/TP/SPAM)
--========================

-- ID PERMITIDO
local allowedPlaceId = 109983668079237

local player = game.Players.LocalPlayer

if game.PlaceId ~= allowedPlaceId then
    player:Kick("Wrong game, runs on SAB.")
    return
end

-- SERVICES
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")

-- PLAYER
local player = Players.LocalPlayer
local plotsFolder = workspace:FindFirstChild("Plots")

-- VARI√ÅVEIS GLOBAIS
local instanStealActive = false
local autoKickActive = false

-- VARI√ÅVEIS DO SCRIPT DE ESP/TP
local baseEspInstances = {}
local teleportTriggered = false
local lastWasZero = false
local espConnection = nil

--------------------------------------------------
-- AUTO KICK QUANDO APARECER "YOU STOLE"
--------------------------------------------------

local keyword = "you stole"

local function hasKeyword(text)
	if typeof(text) ~= "string" then return false end
	return string.find(string.lower(text), keyword) ~= nil
end

local function kickIfEnabled()
	if autoKickActive then
		player:Kick("Voc√™ acabou de roubar, tomara que tenha sido coisa boa kkkkk")
	end
end

local function monitorGuiObject(obj)
	if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
		
		-- Verifica imediatamente
		if hasKeyword(obj.Text) then
			kickIfEnabled()
		end
		
		-- Verifica quando o texto mudar
		obj:GetPropertyChangedSignal("Text"):Connect(function()
			if hasKeyword(obj.Text) then
				kickIfEnabled()
			end
		end)
	end
end

-- Monitorar tudo que j√° existe
task.spawn(function()
	for _, obj in ipairs(player.PlayerGui:GetDescendants()) do
		monitorGuiObject(obj)
	end
end)

-- Monitorar novos elementos
player.PlayerGui.DescendantAdded:Connect(function(obj)
	monitorGuiObject(obj)
end)

-- BASE MARCADA (TP S√ì FUNCIONA PERTO DELA)
local pos1 = Vector3.new(-345.53, -7.00, 94.85)
local pos2 = Vector3.new(-336.24, -4.89, 91.77)
local pos3 = Vector3.new(-360.78, -7.00, 57.96)
local maxDistance = 50

-- C√ÇMERA FIXA PERSONALIZADA
local fixedCamPosition = Vector3.new(-336.45, -1.93, 104.31)
local fixedLookVector = Vector3.new(-0.011, -0.118, -0.993)

-- LIMPA GUI ANTIGA
pcall(function()
	player.PlayerGui.MenuLag:Destroy()
end)

-- ================= FUN√á√ïES DO SCRIPT DE ESP/TP/SPAM =================

-- CRIAR ESP DAS BASES
local function createBaseESP(plot, mainPart)
	if baseEspInstances[plot.Name] then
		baseEspInstances[plot.Name]:Destroy()
	end

	local billboard = Instance.new("BillboardGui")  
	billboard.Name = "rznnq" .. plot.Name  
	billboard.Size = UDim2.new(0, 50, 0, 25)  
	billboard.StudsOffset = Vector3.new(0, 5, 0)  
	billboard.AlwaysOnTop = true  
	billboard.Adornee = mainPart  
	billboard.MaxDistance = 1000  
	billboard.Parent = plot  

	local label = Instance.new("TextLabel")  
	label.Size = UDim2.new(1, 0, 1, 0)  
	label.BackgroundTransparency = 1  
	label.Font = Enum.Font.GothamBold  
	label.TextSize = 14  
	label.TextColor3 = Color3.fromRGB(0, 0, 0)  
	label.TextStrokeTransparency = 0  
	label.TextStrokeColor3 = Color3.fromRGB(128, 0, 128)  
	label.Parent = billboard  

	baseEspInstances[plot.Name] = billboard  
	return billboard
end

-- PEGAR PLAYER MAIS PR√ìXIMO
local function getNearestPlayer()
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return nil
	end

	local root = character.HumanoidRootPart  
	local closest = nil  
	local shortestDistance = math.huge  
  
	for _, p in pairs(Players:GetPlayers()) do  
		if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then  
			local distance = (p.Character.HumanoidRootPart.Position - root.Position).Magnitude  
		  
			if distance < shortestDistance then  
				shortestDistance = distance  
				closest = p  
			end  
		end  
	end  
  
	return closest
end

-- ENVIAR COMANDOS
local function sendCommands(targetPlayer)
	if not targetPlayer then 
		print("Nenhum jogador pr√≥ximo encontrado para enviar comandos")
		return 
	end
	
	local targetName = targetPlayer.Name
	print("Enviando comandos para: " .. targetName)
	
	local commands = {
		";rocket " .. targetName,
		";ragdoll " .. targetName,
		";balloon " .. targetName,
		";inverse " .. targetName,
		";nightvision " .. targetName,
		";pequeno " .. targetName,
		";jumpscare " .. targetName,
		";morph " .. targetName
	}

	local channel = TextChatService.TextChannels.RBXGeneral
  
	for _, cmd in ipairs(commands) do  
		channel:SendAsync(cmd)  
		task.wait(0.12)  
	end
	
	print("Comandos enviados com sucesso para " .. targetName)
end

-- EQUIPAR TAPETE
local function equipCarpet()
	local char = player.Character
	local backpack = player:FindFirstChild("Backpack")
	if not char or not backpack then return end

	local tool = backpack:FindFirstChild("Flying Carpet")  
	if tool then  
		tool.Parent = char  
	end
end

local function unequipCarpet()
	local char = player.Character
	if not char then return end

	local tool = char:FindFirstChild("Flying Carpet")  
	if tool then  
		tool.Parent = player.Backpack  
	end
end

-- TELEPORT + SPAM
local function doTeleportAndSpam()
	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")
	local camera = workspace.CurrentCamera

	task.wait(0.95)  
	equipCarpet()  

	-- TP 1  
	hrp.CFrame = CFrame.new(pos1 + Vector3.new(0,3,0))  
	task.wait(0.01)  

	-- TP 2  
	hrp.CFrame = CFrame.new(pos2 + Vector3.new(0,3,0))  
	task.wait(1.05)  
	
	-- TP 3  
hrp.CFrame = CFrame.new(pos3 + Vector3.new(0,3,0))  
task.wait(1.05)

	-- FIXAR C√ÇMERA  
	local holdTime = 0.50  
	local startTime = tick()  

	camera.CameraType = Enum.CameraType.Scriptable  

	while tick() - startTime < holdTime do  
		camera.CFrame = CFrame.new(  
			fixedCamPosition,  
			fixedCamPosition + fixedLookVector  
		)  
		RunService.RenderStepped:Wait()  
	end  

	camera.CameraType = Enum.CameraType.Custom  

	unequipCarpet()
	
	-- SPAM NO PLAYER MAIS PR√ìXIMO (s√≥ se Instant Steal estiver ON)
	if instanStealActive then
		task.wait(0.2)
		local nearestPlayer = getNearestPlayer()
		sendCommands(nearestPlayer)
	end
end

-- LOOP PRINCIPAL DO ESP (sempre ativo)
local function updateBaseESP()
	if not plotsFolder then return end

	local nearestTimeLabel  
	local nearestDistance = math.huge  

	for _, plot in ipairs(plotsFolder:GetChildren()) do  
		local purchases = plot:FindFirstChild("Purchases")  
		local plotBlock = purchases and purchases:FindFirstChild("PlotBlock")  
		local mainPart = plotBlock and plotBlock:FindFirstChild("Main")  

		local billboard = baseEspInstances[plot.Name]  

		local timeLabel = mainPart  
			and mainPart:FindFirstChild("BillboardGui")  
			and mainPart.BillboardGui:FindFirstChild("RemainingTime")  

		if timeLabel and mainPart then  
			billboard = billboard or createBaseESP(plot, mainPart)  
			local label = billboard:FindFirstChildWhichIsA("TextLabel")  
			if label then  
				label.Text = timeLabel.Text  
			end  

			-- MONITORA S√ì BASE MARCADA (para TP autom√°tico)
			local dist1 = (mainPart.Position - pos1).Magnitude  
			local dist2 = (mainPart.Position - pos2).Magnitude  
			local distance = math.min(dist1, dist2)  

			if distance <= maxDistance and distance < nearestDistance then  
				nearestDistance = distance  
				nearestTimeLabel = timeLabel  
			end  
		elseif billboard then  
			billboard:Destroy()  
			baseEspInstances[plot.Name] = nil  
		end  
	end  

	-- AUTO TP S√ì SE INSTANT STEAL ESTIVER ATIVO
	if instanStealActive and nearestTimeLabel then  
		local timeNumber = tonumber(nearestTimeLabel.Text:match("%d+"))  

		if timeNumber == 1 then  
			if not lastWasZero and not teleportTriggered then  
				teleportTriggered = true  

				task.delay(1.00, function()
					doTeleportAndSpam()
				end)
			end  
			lastWasZero = true
		else  
			lastWasZero = false  
			teleportTriggered = false  
		end  
	end
end

-- FUN√á√ÉO PARA LIMPAR APENAS OS DADOS DE TP (manter ESP visual)
local function resetTPData()
	teleportTriggered = false
	lastWasZero = false
end

--------------------------------------------------
-- GUI
--------------------------------------------------
local gui = Instance.new("ScreenGui", player.PlayerGui)
gui.Name = "MenuLag"
gui.ResetOnSpawn = false

local main = Instance.new("Frame", gui)
main.Size = UDim2.new(0,200,0,153)
main.Position = UDim2.new(0.5,-140,0.5,-95)
main.BackgroundColor3 = Color3.fromRGB(0,0,0)
main.BackgroundTransparency = 0.25
main.Active = true
Instance.new("UICorner", main).CornerRadius = UDim.new(0,12)

local stroke = Instance.new("UIStroke", main)
stroke.Thickness = 3
stroke.Color = Color3.fromRGB(160,0,255)

-- TOP BAR
local top = Instance.new("Frame", main)
top.Size = UDim2.new(1,0,0,45)
top.BackgroundTransparency = 1

local title = Instance.new("TextLabel", top)
title.Size = UDim2.new(1,-50,1,0)
title.Position = UDim2.new(0,10,0,0)
title.BackgroundTransparency = 1
title.Text = "SNIPEX ITS"
title.Font = Enum.Font.GothamBlack
title.TextSize = 20
title.TextColor3 = Color3.fromRGB(255,255,255)
title.TextStrokeColor3 = Color3.fromRGB(160,0,255)
title.TextStrokeTransparency = 0
title.TextXAlignment = Enum.TextXAlignment.Left

-- MINIMIZE
local minimize = Instance.new("TextButton", top)
minimize.Size = UDim2.new(0,35,0,30)
minimize.Position = UDim2.new(1,-40,0,8)
minimize.Text = "-"
minimize.Font = Enum.Font.GothamBlack
minimize.TextSize = 22
minimize.TextColor3 = Color3.fromRGB(180,0,255)
minimize.BackgroundTransparency = 1

-- DIVIDER
local divider = Instance.new("Frame", main)
divider.Size = UDim2.new(1, 0, 0, 2)
divider.Position = UDim2.new(0, 0, 0, 52)
divider.BackgroundColor3 = Color3.fromRGB(160,0,255)

-- CONTAINER
local container = Instance.new("Frame", main)
container.Size = UDim2.new(1,0,1,-60)
container.Position = UDim2.new(0,0,0,60)
container.BackgroundTransparency = 1

--------------------------------------------------
-- FUN√á√ÉO PARA ALTERNAR ESTADO DO BOT√ÉO
--------------------------------------------------
local function toggleButton(btn, isActive)
	if isActive then
		-- Anima√ß√£o para roxo (ON)
		local t1 = TweenService:Create(
			btn,
			TweenInfo.new(0.2),
			{BackgroundColor3 = Color3.fromRGB(160, 0, 255)}
		)
		t1:Play()
		btn.Text = btn.Name == "instanStealBtn" and "INSTAN STEAL: ON" or "AUTO KICK: ON"
	else
		-- Anima√ß√£o para preto (OFF)
		local t1 = TweenService:Create(
			btn,
			TweenInfo.new(0.2),
			{BackgroundColor3 = Color3.fromRGB(0, 0, 0)}
		)
		t1:Play()
		btn.Text = btn.Name == "instanStealBtn" and "INSTAN STEAL: OFF" or "AUTO KICK: OFF"
	end
end

--------------------------------------------------
-- ANIMA√á√ÉO DE CLIQUE
--------------------------------------------------
local function clickAnimation(btn)
	local t1 = TweenService:Create(
		btn,
		TweenInfo.new(0.12),
		{BackgroundColor3 = Color3.fromRGB(160,0,255)}
	)
	local t2 = TweenService:Create(
		btn,
		TweenInfo.new(0.18),
		{BackgroundColor3 = btn.Name == "instanStealBtn" and (instanStealActive and Color3.fromRGB(160,0,255) or Color3.fromRGB(0,0,0)) 
			or (autoKickActive and Color3.fromRGB(160,0,255) or Color3.fromRGB(0,0,0))}
	)
	t1:Play()
	t1.Completed:Wait()
	t2:Play()
end

--------------------------------------------------
-- BOT√ÉO BASE
--------------------------------------------------
local function baseButton(text, y)
	local btn = Instance.new("TextButton", container)
	btn.Size = UDim2.new(1,-30,0,35)
	btn.Position = UDim2.new(0,15,0,y)
	btn.Text = text
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 16
	btn.TextColor3 = Color3.new(1,1,1)
	btn.BackgroundColor3 = Color3.fromRGB(0,0,0)
	btn.BackgroundTransparency = 0.15
	btn.AutoButtonColor = false
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)

	local s = Instance.new("UIStroke", btn)
	s.Thickness = 2
	s.Color = Color3.fromRGB(160,0,255)

	return btn
end

--------------------------------------------------
-- BOT√ÉO INSTAN STEAL (controla TP + Spam, ESP continua sempre)
--------------------------------------------------
local instanStealBtn = baseButton("INSTAN STEAL: OFF", 0)
instanStealBtn.Name = "instanStealBtn"

instanStealBtn.MouseButton1Click:Connect(function()
	clickAnimation(instanStealBtn)
	instanStealActive = not instanStealActive
	toggleButton(instanStealBtn, instanStealActive)
	
	-- S√≥ reseta os dados de TP, n√£o mexe no ESP visual
	resetTPData()
	
	if instanStealActive then
		print("üîµ Instant Steal ATIVADO - TP e Spam prontos!")
	else
		print("‚ö´ Instant Steal DESATIVADO - TP e Spam desligados, ESP continua")
	end
end)

--------------------------------------------------
-- BOT√ÉO AUTO KICK (ON/OFF) - SEM FUN√á√ÉO POR ENQUANTO
--------------------------------------------------
local autoKickBtn = baseButton("AUTO KICK: OFF", 45)
autoKickBtn.Name = "autoKickBtn"

autoKickBtn.MouseButton1Click:Connect(function()
	clickAnimation(autoKickBtn)
	autoKickActive = not autoKickActive
	toggleButton(autoKickBtn, autoKickActive)
	-- AINDA SEM FUN√á√ÉO (pode adicionar depois)
end)

--------------------------------------------------
-- CR√âDITOS
--------------------------------------------------
local credits = Instance.new("TextLabel", container)
credits.Size = UDim2.new(1,0,0,18)
credits.Position = UDim2.new(0,0,0,77)
credits.BackgroundTransparency = 1
credits.Text = "Criado por Felipe_Umc"
credits.Font = Enum.Font.GothamBold
credits.TextSize = 12
credits.TextColor3 = Color3.fromRGB(255,255,255)
credits.TextStrokeColor3 = Color3.fromRGB(160,0,255)
credits.TextStrokeTransparency = 0.4

--------------------------------------------------
-- MINIMIZAR
--------------------------------------------------
local minimized = false
minimize.MouseButton1Click:Connect(function()
	minimized = not minimized
	container.Visible = not minimized
	divider.Visible = not minimized
	main.Size = minimized and UDim2.new(0,200,0,45) or UDim2.new(0,200,0,153)
	
	minimize.Text = minimized and "+" or "-"
end)

--------------------------------------------------
-- ARRASTAR MENU
--------------------------------------------------
local dragging, dragStart, startPos

top.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1
	or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = main.Position
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1
	or input.UserInputType == Enum.UserInputType.Touch then
		dragging = false
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and (
		input.UserInputType == Enum.UserInputType.MouseMovement
		or input.UserInputType == Enum.UserInputType.Touch
	) then
		local delta = input.Position - dragStart
		main.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end
end)

--------------------------------------------------
-- ANIMA√á√ÉO DA BORDA
--------------------------------------------------
local DARK_TIME = 0.5
local PURPLE_TIME = 1.6

task.spawn(function()
	while true do
		-- DARK
		local darkStroke = TweenService:Create(
			stroke,
			TweenInfo.new(DARK_TIME, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ Color = Color3.fromRGB(30, 0, 45) }
		)

		local darkDivider = TweenService:Create(
			divider,
			TweenInfo.new(DARK_TIME, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ BackgroundColor3 = Color3.fromRGB(30, 0, 45) }
		)

		darkStroke:Play()
		darkDivider:Play()
		darkStroke.Completed:Wait()

		-- PURPLE
		local purpleStroke = TweenService:Create(
			stroke,
			TweenInfo.new(PURPLE_TIME, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ Color = Color3.fromRGB(160, 0, 255) }
		)

		local purpleDivider = TweenService:Create(
			divider,
			TweenInfo.new(PURPLE_TIME, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ BackgroundColor3 = Color3.fromRGB(160, 0, 255) }
		)

		purpleStroke:Play()
		purpleDivider:Play()
		purpleStroke.Completed:Wait()
	end
end)

-- INICIA O LOOP DO ESP (sempre ativo)
espConnection = RunService.RenderStepped:Connect(updateBaseESP)

--[[
    AUTO GRAB DO MAIS PR√ìXIMO
    S√≥ pega o animal mais pr√≥ximo, SEMPRE ATIVO
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

if not game:IsLoaded() then game.Loaded:Wait() end
task.wait(1)

-- Cache simples
local PromptCache = {}

-- Pegar HRP
local function getHRP()
    local char = LocalPlayer.Character
    return char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("UpperTorso"))
end

-- Encontrar prompt do animal
local function findPrompt(plotName, slot)
    local key = plotName .. "_" .. slot
    if PromptCache[key] and PromptCache[key].Parent then return PromptCache[key] end
    
    local plot = workspace.Plots and workspace.Plots:FindFirstChild(plotName)
    if not plot then return nil end
    
    local podium = plot:FindFirstChild("AnimalPodiums") and 
                   plot.AnimalPodiums:FindFirstChild(slot)
    if not podium then return nil end
    
    local base = podium:FindFirstChild("Base")
    if not base then return nil end
    
    local spawn = base:FindFirstChild("Spawn")
    if not spawn then return nil end
    
    local attach = spawn:FindFirstChild("PromptAttachment")
    if not attach then return nil end
    
    for _, p in ipairs(attach:GetChildren()) do
        if p:IsA("ProximityPrompt") then
            PromptCache[key] = p
            return p
        end
    end
    return nil
end

-- Pegar posi√ß√£o do animal
local function getPos(plotName, slot)
    local plot = workspace.Plots and workspace.Plots:FindFirstChild(plotName)
    if not plot then return nil end
    
    local podium = plot:FindFirstChild("AnimalPodiums") and 
                   plot.AnimalPodiums:FindFirstChild(slot)
    return podium and podium:GetPivot().Position
end

-- Ativar grab (direto, sem frescura)
local function grab(prompt)
    if not prompt then return false end
    local ok, conns = pcall(getconnections, prompt.Triggered)
    if ok and type(conns) == "table" then
        for _, conn in ipairs(conns) do
            if type(conn.Function) == "function" then
                task.spawn(conn.Function)
            end
        end
        return true
    end
    pcall(fireproximityprompt, prompt)
    return true
end

-- Fun√ß√£o pra ver se o animal √© seu (igual ao BK's Hub)
local function isMine(plotName)
    local plot = workspace.Plots and workspace.Plots:FindFirstChild(plotName)
    if not plot then return false end
    
    local Sync = require(ReplicatedStorage.Packages.Synchronizer)
    local channel = Sync:Get(plot.Name)
    if channel then
        local owner = channel:Get("Owner")
        if owner then
            if typeof(owner) == "Instance" then
                return owner == LocalPlayer
            elseif typeof(owner) == "table" and owner.UserId then
                return owner.UserId == LocalPlayer.UserId
            end
        end
    end
    return false
end

-- Scan dos animais
local function scanAnimals()
    local animals = {}
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return animals end
    
    local Sync = require(ReplicatedStorage.Packages.Synchronizer)
    
    for _, plot in ipairs(plots:GetChildren()) do
        if isMine(plot.Name) then continue end -- PULA SE FOR SEU
        
        local channel = Sync:Get(plot.Name)
        if channel then
            local list = channel:Get("AnimalList")
            if list then
                for slot, data in pairs(list) do
                    if type(data) == "table" then
                        local pos = getPos(plot.Name, tostring(slot))
                        table.insert(animals, {
                            plot = plot.Name,
                            slot = tostring(slot),
                            pos = pos,
                            dist = pos and getHRP() and (getHRP().Position - pos).Magnitude or math.huge
                        })
                    end
                end
            end
        end
    end
    
    return animals
end

-- LOOP PRINCIPAL (S√ì O MAIS PR√ìXIMO)
while true do
    task.wait(1.03) -- MAIS R√ÅPIDO
    
    local hrp = getHRP()
    if not hrp then continue end
    
    local animals = scanAnimals()
    if #animals == 0 then continue end
    
    -- ACHA O MAIS PR√ìXIMO
    local nearest = nil
    local minDist = math.huge
    
    for _, a in ipairs(animals) do
        if a.dist and a.dist < minDist then
            minDist = a.dist
            nearest = a
        end
    end
    
    if nearest and minDist <= 30 then
        local prompt = findPrompt(nearest.plot, nearest.slot)
        if prompt then
            grab(prompt)
        end
    end
end

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local FFlags = {
    GameNetPVHeaderRotationalVelocityZeroCutoffExponent = -5000,
    LargeReplicatorWrite5 = true,
    LargeReplicatorEnabled9 = true,
    AngularVelociryLimit = 360,
    TimestepArbiterVelocityCriteriaThresholdTwoDt = 2147483646,
    S2PhysicsSenderRate = 15000,
    DisableDPIScale = true,
    MaxDataPacketPerSend = 2147483647,
    PhysicsSenderMaxBandwidthBps = 20000,
    TimestepArbiterHumanoidLinearVelThreshold = 21,
    MaxMissedWorldStepsRemembered = -2147483648,
    PlayerHumanoidPropertyUpdateRestrict = true,
    SimDefaultHumanoidTimestepMultiplier = 0,
    StreamJobNOUVolumeLengthCap = 2147483647,
    DebugSendDistInSteps = -2147483648,
    GameNetDontSendRedundantNumTimes = 1,
    CheckPVLinearVelocityIntegrateVsDeltaPositionThresholdPercent = 1,
    CheckPVDifferencesForInterpolationMinVelThresholdStudsPerSecHundredth = 1,
    LargeReplicatorSerializeRead3 = true,
    ReplicationFocusNouExtentsSizeCutoffForPauseStuds = 2147483647,
    CheckPVCachedVelThresholdPercent = 10,
    CheckPVDifferencesForInterpolationMinRotVelThresholdRadsPerSecHundredth = 1,
    GameNetDontSendRedundantDeltaPositionMillionth = 1,
    InterpolationFrameVelocityThresholdMillionth = 5,
    StreamJobNOUVolumeCap = 2147483647,
    InterpolationFrameRotVelocityThresholdMillionth = 5,
    CheckPVCachedRotVelThresholdPercent = 10,
    WorldStepMax = 30,
    InterpolationFramePositionThresholdMillionth = 5,
    TimestepArbiterHumanoidTurningVelThreshold = 1,
    SimOwnedNOUCountThresholdMillionth = 2147483647,
    GameNetPVHeaderLinearVelocityZeroCutoffExponent = -5000,
    NextGenReplicatorEnabledWrite4 = true,
    TimestepArbiterOmegaThou = 1073741823,
    MaxAcceptableUpdateDelay = 1,
    LargeReplicatorSerializeWrite4 = true
}

-- Aplicar FFlags
for name, value in pairs(FFlags) do
    pcall(function()
        setfflag(tostring(name), tostring(value))
    end)
end

-- Fun√ß√£o de respawn
local function respawn(plr)
    local char = plr.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.Dead)
        end
        char:ClearAllChildren()
        local newChar = Instance.new("Model")
        newChar.Parent = workspace
        plr.Character = newChar
        task.wait()
        plr.Character = char
        newChar:Destroy()
    end
end